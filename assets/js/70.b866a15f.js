(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{497:function(e,t,o){"use strict";o.r(t);var i=o(36),v=Object(i.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"dfs"}},[e._v("DFS")]),e._v(" "),o("p",[e._v("常见的 DFS 用来解决什么问题？(1) 图中 (有向无向皆可) 的符合某种特征 (比如最长) 的路径以及长度 (2) 排列组合 (3) 遍历一个图 (或者树)(4) 找出图或者树中符合题目要求的全部方案")]),e._v(" "),o("p",[e._v("DFS 基本模板 (需要记录路径，不需要返回值 and 不需要记录路径，但需要记录某些特征的返回值)")]),e._v(" "),o("p",[e._v("除了遍历之外多数情况下时间复杂度是指数级别，一般是 O (方案数 × 找到每个方案的时间复杂度)")]),e._v(" "),o("p",[e._v("递归题目都可以用非递归迭代的方法写，但一般实现起来非常麻烦")]),e._v(" "),o("p",[e._v("基于树的 DFS：需要记住递归写前序中序后序遍历二叉树的模板")]),e._v(" "),o("ul",[o("li",[e._v("Leetcode 543 Diameter of Binary Tree")]),e._v(" "),o("li",[e._v("Leetcode 226 Invert Binary Tree")]),e._v(" "),o("li",[e._v("Leetcode 101 Symmetric Tree")]),e._v(" "),o("li",[e._v("Leetcode 951 Flip Equivalent Binary Trees")]),e._v(" "),o("li",[e._v("Leetcode 124 Binary Tree Maximum Path Sum")]),e._v(" "),o("li",[e._v("Leetcode 236 Lowest Common Ancestor of a Binary Tree (相似题：235、1650)")]),e._v(" "),o("li",[e._v("Leetcode 105 Construct Binary Tree from Preorder and Inorder Traversal")]),e._v(" "),o("li",[e._v("Leetcode 104 Maximum Depth of Binary Tree")]),e._v(" "),o("li",[e._v("Leetcode 987 Vertical Order Traversal of a Binary Tree")]),e._v(" "),o("li",[e._v("Leetcode 1485 Clone Binary Tree With Random Pointer")]),e._v(" "),o("li",[e._v("Leetcode 572 Subtree of Another Tree")]),e._v(" "),o("li",[e._v("Leetcode 863 All Nodes Distance K in Binary Tree")]),e._v(" "),o("li",[e._v("Leetcode 1110 Delete Nodes And Return Forest")])]),e._v(" "),o("p",[e._v("二叉搜索树 (BST)：BST 特征：中序遍历为单调递增的二叉树，换句话说，根节点的值比左子树任意节点值都大，比右子树任意节点值都小，增删查改均为 O (h) 复杂度，h 为树的高度；注意不是所有的 BST 题目都需要递归，有的题目只需要 while 循环即可")]),e._v(" "),o("ul",[o("li",[e._v("Leetcode 230 Kth Smallest element in a BST")]),e._v(" "),o("li",[e._v("Leetcode 98 Validate Binary Search Tree")]),e._v(" "),o("li",[e._v("Leetcode 270 Cloest Binary Search Tree Value")]),e._v(" "),o("li",[e._v("Leetcode 235 Lowest Common Ancestor of a Binary Search Tree")]),e._v(" "),o("li",[e._v("Leetcode 669 Trim a Binary Search Tree")]),e._v(" "),o("li",[e._v("Leetcode 700 Search in a Binary Search Tree")]),e._v(" "),o("li",[e._v("Leetcode 108 Convert Sorted Array to Binary Search Tree")]),e._v(" "),o("li",[e._v("Leetcode 333 Largest BST Subtree (与 98 类似)")]),e._v(" "),o("li",[e._v("Leetcode 285 Inorder Successor in BST (I，II)")])]),e._v(" "),o("p",[e._v("基于图的 DFS：和 BFS 一样一般需要一个 set 来记录访问过的节点，避免重复访问造成死循环；Word XXX 系列面试中非常常见，例如 word break，word ladder，word pattern，word search。")]),e._v(" "),o("ul",[o("li",[e._v("Leetcode 341 Flatten Nested List Iterator (339 364)")]),e._v(" "),o("li",[e._v("Leetcode 394 Decode String")]),e._v(" "),o("li",[e._v("Leetcode 51 N-Queens (I II 基本相同)")]),e._v(" "),o("li",[e._v("Leetcode 291 Word Pattern II (I 为简单的 Hashmap 题)")]),e._v(" "),o("li",[e._v("Leetcode 126 Word Ladder II (I 为 BFS 题目)")]),e._v(" "),o("li",[e._v("Leetcode 93 Restore IP Addresses")]),e._v(" "),o("li",[e._v("Leetcode 22 Generate Parentheses")]),e._v(" "),o("li",[e._v("Leetcode 586 Score of Parentheses")]),e._v(" "),o("li",[e._v("Leetcode 301 Remove Invalid Parentheses")]),e._v(" "),o("li",[e._v("Leetcode 37 Sodoku Solver")]),e._v(" "),o("li",[e._v("Leetcode 212 Word Search II (I，II)")]),e._v(" "),o("li",[e._v("Leetcode 1087 Brace Expansion")]),e._v(" "),o("li",[e._v("Leetcode 399 Evaluate Division")]),e._v(" "),o("li",[e._v("Leetcode 1274 Number of Ships in a Rectangle")]),e._v(" "),o("li",[e._v("Leetcode 1376 Time Needed to Inform All Employees")]),e._v(" "),o("li",[e._v("Leetcode 694 Number of Distinct Islands")]),e._v(" "),o("li",[e._v("Leetcode 131 Palindrome Partitioning")])]),e._v(" "),o("p",[e._v("基于排列组合的 DFS：其实与图类 DFS 方法一致，但是排列组合的特征更明显")]),e._v(" "),o("ul",[o("li",[e._v("Leetcode 17 Letter Combinations of a Phone Number")]),e._v(" "),o("li",[e._v("Leetcode 39 Combination Sum (I，II，III 相似，IV 为动态规划题目)")]),e._v(" "),o("li",[e._v("Leetcode 78 Subsets (I，II 重点在于如何去重)")]),e._v(" "),o("li",[e._v("Leetcode 46 Permutation (I，II 重点在于如何去重)")]),e._v(" "),o("li",[e._v("Leetcode 77 Combinations (I，II 重点在于如何去重)")]),e._v(" "),o("li",[e._v("Leetcode 698 Partition to K Equal Sum Subsets")]),e._v(" "),o("li",[e._v("Leetcode 526 Beautiful Arrangement (similar to 46)")])]),e._v(" "),o("p",[e._v("记忆化搜索 (DFS + Memoization Search)：算是动态规划的一种，递归每次返回时同时记录下已访问过的节点特征，避免重复访问同一个节点，可以有效的把指数级别的 DFS 时间复杂度降为多项式级别；注意这一类的 DFS 必须在最后有返回值，不可以用排列组合类型的 DFS 方法写；for 循环的 dp 题目都可以用记忆化搜索的方式写，但是不是所有的记忆化搜索题目都可以用 for 循环的 dp 方式写。")]),e._v(" "),o("ul",[o("li",[e._v("Leetcode 139 Word Break II")]),e._v(" "),o("li",[e._v("Leetcode 72 Edit Distance")]),e._v(" "),o("li",[e._v("Leetcode 377 Combination Sum IV")]),e._v(" "),o("li",[e._v("Leetcode 1235 Maximum Profit in Job Scheduling")]),e._v(" "),o("li",[e._v("Leetcode 1335 Minimum Difficulty of a Job Schedule")]),e._v(" "),o("li",[e._v("Leetcode 1216 Valid Palindrome III")]),e._v(" "),o("li",[e._v("Leetcode 97 Interleaving String")]),e._v(" "),o("li",[e._v("Leetcode 472 Concatenated Words")]),e._v(" "),o("li",[e._v("Leetcode 403 Frog Jump")]),e._v(" "),o("li",[e._v("Leetcode 329 Longest Increasing Path in a Matrix")])])])}),[],!1,null,null,null);t.default=v.exports}}]);