(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{439:function(e,t,r){"use strict";r.r(t);var n=r(36),o=Object(n.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"ebpf"}},[e._v("eBPF")]),e._v(" "),r("p",[e._v("eBPF 的全称是 extend berkeley package filter (扩展的伯克利包过滤器)，目前已经集成在了 5.0 以上的 Linux kernel 中，使用 "),r("code",[e._v("uname -r")]),e._v(" 可以发现自己的 Linux 版本号，eBPF 的核心思想是"),r("strong",[e._v("内核空间的虚拟化")]),e._v("，平时我们谈论的虚拟机是使用 x86_64 或者是 arm64 的指令集去模拟出一个完整的计算机系统，但这里说的的虚拟机仅限内核使用，为了安全性它的功能是受限的。")]),e._v(" "),r("p",[e._v("我们知道 Linux 操作系统是宏内核的系统，它分为内核态和用户态，因为宏内核的缘故，Linux 的内核拥有非常多的功能，这一点跟微内核不同，为了安全性用户进程 (就是一般程序员写的普遍性的那种的进程) 都是运行在用户态的，用户态和内核态进行数据的复制是降低效率的，那么为了提高效率，将在用户态运行的程序 (它势必需要跟内核态进行交流) 直接全部运行在内核态岂不是能提高效率，因为不需要数据的从内核态到用户态的复制传输了，因为可以运行在内核态的虚拟机应运而生，我们在用户态写的需要在内核态运行的代码，经过一系列的编译，验证，等操作就可以运行在内核态，并且内核态和用户态之间还存在可以进行状态查看的日志表，所以，我们即可以提高效率，又可以了解代码的执行状态。")]),e._v(" "),r("p",[e._v("因为不能让我们直接操作内核态中的各项子系统，所以 eBPF 提供了一系列的辅助函数，来帮助跟其它内核态的子系统进行交互，这样可以确保更高的安全性，为了更高的安全性，编译的字节码在装载到 bpf 中时都会进行一些列的验证，总而言之，安全是 eBPF 的又一大特点。")]),e._v(" "),r("p",[e._v("目前，eBPF 主要用在"),r("strong",[e._v("故障诊断")]),e._v("，"),r("strong",[e._v("网络优化")]),e._v("，"),r("strong",[e._v("安全控制")]),e._v("，"),r("strong",[e._v("性能监控")]),e._v("等领域，比如 "),r("a",{attrs:{href:"https://cilium.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("cilium"),r("OutboundLink")],1),e._v(" 项目就是以 go 为编程语言的 eBPF 项目，它主要关注于容器的安全，另外还有 "),r("a",{attrs:{href:"https://github.com/iovisor/bcc",target:"_blank",rel:"noopener noreferrer"}},[e._v("bcc"),r("OutboundLink")],1),e._v(" 项目，它提供了一系列的关于 eBPF 的工具，主要语言是 c 和 Python。")])])}),[],!1,null,null,null);t.default=o.exports}}]);